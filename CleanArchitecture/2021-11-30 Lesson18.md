시스템 아키텍처는 소프트웨어 컴포넌트와 그 컴포넌트를 분리하는 경계에 의해 정의됨.
경계는 다양한 형태로 나타남.

### 경계 횡단하기

런타임에 경계를 횡단함.
→ 한쪽경계에서 다른쪽으로 데이터를 넘김.
소스코드 의존성관리를 통에 적절한 위치에 경계횡단 가능.

### 두려운 단일체

배포관점에서 볼 때 소스수준 분리모드 즉, 단일체(monolith)는 경계가 드러나지 않는다.

그러나 경계가 존재하지않거나 경계자체가 무의미하지않음.!

→ 정적으로 링크된 단일 실행파일을 만들더라도 그안에 포함된 다양한 컴포넌트를 개발하고 바이너리로만드는 과정을 독립적으로 수행하기 때문.

가장 단순한 형태의 경계횡단 → 저수준 클라이언트에서 고수준 서비스의 함수를 호출.

![스크린샷 2021-11-30 오후 4.21.23.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/577e9a05-a54c-4efb-994a-829cf5c3d5b1/스크린샷_2021-11-30_오후_4.21.23.png)

왼쪽에서 오른쪽으로 경계를 횡단함.

만약 고수준 클라이언트가 저수준 서비스를 호출해야 한다면 의존성을 역전시킴.

![스크린샷 2021-11-30 오후 4.22.21.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35a7e630-f3c8-4889-b5ac-70dc45bacd77/스크린샷_2021-11-30_오후_4.22.21.png)

모두 오른쪽에서 왼쪽으로 경계를 횡단함.
고수준은 저수준(세부사항)으로 부터 독립적으로 유지시켜야 함.

### 결론

단일체 말고는 대다수가 한가지 이상 경계전략 사용하는데, DIP원칙을 따라야한다

저수준 컴포넌트가 고수준 컴포넌트를 의존해야한다.

1. **상위 모듈**은 **하위 모듈**에 의존해서는 안된다
2. 추상화는 세부 사항에 의존해서는 안된다
