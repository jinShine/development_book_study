# SRP: 단일 책임 원칙

> **하나의 모듈은 하나의 액터에 대해서만 책임져야 한다.**

액터: 변경을 요청하는 집단을 의미

모듈: 함수와 데이터 구조로 구성된 응집된 집합(보통은 소스 파일)을 의미

**책임은 무엇이며 클래스에 하나만 있는지 여부를 아는 방법은 무엇입니까?** 

책임은 클래스가 실행에 대한 책임이 있는 역할로 간주될 수 있지만 **이 원칙에 대해 이야기할 때 더 나은 정의는 기본적으로 책임이 변경 사유라는 것**입니다. 
즉, 특정 클래스를 변경해야 하는 이유를 하나 이상 생각할 수 있다면 이는 해당 클래스가 둘 이상의 책임을 지고 있기 때문입니다.

**SRP 원칙을 위반하는 징후들**

- **징후 1: 우발적 중복**
    
    
    Employee라는 단일 클래스에 세 액터가 결합되어졌다고 가정
    
    ![스크린샷 2021-11-15 오전 1.06.16.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b54221d7-1a50-4dc1-a28c-9bc3583cd93e/스크린샷_2021-11-15_오전_1.06.16.png)
    
    - `calculatePay()` 메서드 - 회계팀에서 CFO 보고를 위해 사용
    - `reportHours()` 메서드 - 인사팀에서 COO 보고를 위해 사용
    - `save()` 메서드 - DBA가 CTO 보고를 위해 사용
    
    만약 `calculatePay()`와 `reportHours()` 가 정규 업무 시간을 계산하는 알고리즘을 공유하며, 이 알고리즘을 `regularHours()`라는 메서드 하나로 공유한다면?
    
    CFO에서 정규 업무 시간을 계산하는 방식을 수정 요청하고, 수정하는 개발자가 `regularHours()`가 양쪽에서 호출한다는 사실을 눈치채지 못한다면 CFO 팀에서의 수정이 COO 팀의 로직에 영향을 주게 된다.
    
    SRP는 이러한 상황을 방지하기 위해 서로 다른 액터가 의존하는 코드를 분리하라고 말한다.
    
- **징후 2: 병합**
    
    소스파일에 다양하고 많은 메서드를 포함할수록, 그리고 이 메서드가 서로 다른 액터를 책임질수록 병합이 발생할 가능성이 높다.
    
    CTO 팀에서 데이터베이스의 `Employee` 테이블 스키마를 수정하는 동시에 COO 팀에서 `reportHours()`메서드의 보고서 포맷을 변경하기로 결정한다면 어떻게 될까?
    
    아마 서로 다른 팀에 속한 개발자가 각자 변경사항을 적용하고, 이 변경사항은 충돌할 것이다. 병합에는 당연히 위험이 뒤따른다.
    
    이 문제에서 벗어나는 방법은, 앞서 말했듯이 서로 다른 액터를 뒷받침하는 코드를 분리하는 것이다.

### 결론

- 단일 책임 원칙은 객체지향에서의 메서드와 클래스 수준의 원칙이다. 하지만 상위 수준에서 다른 형태로도 존재한다.
    - 컴포넌트 수준 → 공통 폐쇄 원칙(Common Closure Principle)이 된다.
    - 아키텍처 수준 → 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축(Axis of Change)이 된다.
