# OCP: 개방-폐쇄 원칙

> 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, **변경해서는 안된다.**

**소프트웨어 아키텍처를 공부하는 가장 근본적인 이유**

### 사고 실험(*thought experiment*)

: 사물의 실체나 개념을 이해하기 위해 가상의 시나리오를 이용하는 것이다

재무제표를 보여주는 시스템

예) 재무제표는 제무 데이터를 기준으로 보고서 형태로 변환해서 웹페이지에 출력할 수 있고, 보고서 형태의 이 데이터는 흑백 프린트로 출력이 가능해야 한다.

위의 요구사항에 대해 SRP를 적용하면 다음과 같은 설계가 가능

![IMG_2549.heic](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8b211add-4275-42f1-bcce-f0095180453f/IMG_2549.heic)

여기서 중요한 것은 출력이 두개(웹, 프린터)의 책임으로 분리된다는 사실

이러한 책임이 분리되었다면, 두 책임 중에서 하나에서 변경이 발생하더라도, 다른 하나는 변경되지 않도록 소스 코드 의존성을 신경써서 설계 하여야 한다.

또한 이렇게 설계한 구조에서는 행위가 확장될 때 다른 곳에서 변경이 발생하지 않음을 보장해야 한다.

위의 요구사항을 각각의 4개 컴포넌트로 나누면 다음과 같다.

![스크린샷 2021-11-16 오후 2.05.20.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/49885b2f-21cd-47fa-96c5-3ca3be298e9a/스크린샷_2021-11-16_오후_2.05.20.png)

4개의 컴포넌트는 각각, Controller, Interactor, Presenter, Database이며 위의 컴포넌트들끼리 연결된 화살표 중

- 열린 화살표는 사용(Using)관계
- 닫힌 화살표는 구현(implemet) 또는 상속(inheritance) 관계

여기서 주목할 점은 모든 의존성은 **소스코드** 의존성을 나타낸다는 것이다.

예를들어 화살표가 A클래스에서 B클래스로 향한다면, A클래스에서는 B클래스를 호출하지만, B클래스에서는 A클래스를 호출하지 않는다.

즉 단방향으로 이루어진다.

**단방향은 곧 변경으로부터 보호하려는 의미가 담겨져 있다.**

![스크린샷 2021-11-16 오후 2.24.58.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/74d2f7c2-1d56-46bc-857e-bf545e3466c3/스크린샷_2021-11-16_오후_2.24.58.png)

- Interactor 는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다.
- View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다
- Presenter 는 View보다는 높고 Controller 나 Interactor 보다는 낮은 수준에 위치한다.

이것이 아키텍처 수준에서 OCP 가 동작하는 방식이다.

상황 A와 B가 주어지고 이를 구현에 성공했을때 갑자기 C의 상황이 추가로 들어왔다. 이럴 때 원래 코드를 얼마나 많이 수정해야할까? → 이상적인 변경량 0

- How?
    
    ***단일 책임 원칙과 의존성 역전 원칙을 통해 최소화할 수 있다.*** 서로 다른 목적으로 변경되는 요소를 적절하게 분리(SRP)하고 이들 요소사이의 의존성을 체계화(DIP)함으로써 변경량을 최소화할 수 있다.
    
    - 아키텍트는 기능이 ***어떻게*** | ***왜*** | ***언제*** 발생하는지에 따라서 기능을 분리하고, 분리한 기능을 컴포넌트의 계층 구조로 조직화한다.
    - 이와 같은 변경은 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

### 방향성 제어

FinancialDataGateway 인터페이스는 FinancialReportGenerator 와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다.

이 인터페이스가 없다면 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다.

### 정보 은닉

FinancialReportRequester 인터페이스는 방향성 제어와는 다른 목적을 가진다.

이 녀석은 FinancialReportController 가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해 존재한다.

만약 이 인터페이스가 없었다면, Controller 는 FinancialEntities 에 대해 추이 종속성(transitive dependency)을 가지게 된다.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 **'자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안 된다'**는 소프트웨어 원칙을 위반하게 된다.

### 결론

인터페이스는 의존역전 기능과 정보 은닉을 할수 있다.

OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나이며,

**목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.**

이러한 **목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조**가 만들어지도록 해야 한다.
