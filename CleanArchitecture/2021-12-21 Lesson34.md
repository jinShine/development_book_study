# 세부사항: 빠져 있는 장

**사례**

- 온라인 서점
- 고객이 주문 상태를 조회할 수 있는 유스케이스 구현

**계층 기반 패키지**

단순한 설계방식으로 수평 계층형 아키텍처가있음.
기술적인 관점에서 해당코드가 하는일(service, repository 등)에 기반해서 그 코드를 계층으로 분할하는것

![스크린샷 2021-12-21 오후 4.43.17.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/21f8ba00-b322-448b-aa6f-7f47e371f540/스크린샷_2021-12-21_오후_4.43.17.png)

계층형 아키텍처는 복잡함을 겪지않고 무언가를 작동시켜주지만 업무 도메인에 대해 아무것도 말해주지 않는다.

→ 전혀다른 업무도메인이라도 코드를 계층형 아키텍처로 만들어 나란히 놓고보면 웹, 서비스, 레파지토리로 구성된 모습이 비슷하게 보이기 때문

**기능 기반 패키지**

서로 연관된 기능, 도메인 개념, 또는 Aggregate Root에 기반하여 수직의 얇은 조각으로 코드를 나누는 방식임.

인터페이스와 클래스는 이전과 같지만 모두가 order라는 단 하나의 패키지에 속하게 된다.

따라서

- 상위 수준 구조가 업무 도메인에 대해 무엇인가를 알려주게됨.
- 또한 '주문 조회하기' 유스케이스가 변경될 경우 order라는 한 패키지만 찾으면되기 때문에 수월해짐.

계층기반, 기능기반 둘 중 무엇이 더 낫다 라기보단 저자는 두 접근법 모두 차선책.

- 모든 Aggregate는 Root를 가짐
- 외부에서 객체를 접근 시 반드시 Aggregate root를 통해야함
    
    ![스크린샷 2021-12-21 오후 4.48.45.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5849742a-f02f-42e1-80a9-36e71cb481e4/스크린샷_2021-12-21_오후_4.48.45.png)
    
    포트와 어댑터
    
    포트와 어댑터, 육각형 아키택처 등의 방식으로 접근하는 이유 
    
    → 업무 / 도메인에 초점을 둔 코드가 프레임워크나 데이터베이스 같은 기술적 세부 구현과 독립적이며 분리된 아키텍처를 만들기 위함
    
    ![스크린샷 2021-12-21 오후 4.50.05.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3096969b-8036-45f6-86f0-dea20a17eca2/스크린샷_2021-12-21_오후_4.50.05.png)
    
    com.mycompany.myapp.domain 패키지가 '내부' 도메인 이며 나머지 패키지는 '외부'
    추가로 Orders는 OrdersRepository라는 이름에서 바뀐 이름인데
    DDD에서는 **유비쿼터스 도메인 언어**를 관점으로 기술하라고 했기때문에 반영된것임.
    → 예를들면 도메인에 대해 논의할 때 '주문'에 대해 말하는것이지 '주문 레파지토리'에 대해 말하는것이 아니기 때문임.
    
    - **유비쿼터스 언어란?**
        
        ### Ubiquitous Language (유비쿼터스 언어)
        
        > 유비쿼터스 언어 - 도메인과 관계된 사람들(아키텍처, 개발자 등)이 공통적으로 의미를 이해할 수 있도록 정의하는 모든 단어나 용어들
        > 
        
        예를 들어, 쇼핑몰을 같이 개발하는 사람들끼리 "*우리 쇼핑몰에서 주문서는 OrderForm(오더폼)이라고 명명합니다."* 라고 한다면 OrderForm은 유비쿼터스 언어를 사용한 용어가 되는 것이고 이는 같이 개발하는 사람들끼리는 문서로 정리해두는것이 필요합니다.
        
        또한 주의해야할 점이 있습니다. 쇼핑몰에서 주문이라는 도메인에 관계된 사람들은 개발자만 있는 것은 아닐겁니다. 기획자도 있고 쇼핑몰 사장님도 해당 단어에 대해서 알아야 하겠죠. 개발자들이 쇼핑몰 사장 혹은 기획자에게 에러 이슈에 대해 설명할 상황이 온다고 했을 때 "*16:00시에 들어온 OrderForm에서 특정 이슈가 있어서...*" 라고 이야기 했는데 "*OrderForm이 뭐죠?*" 라는 질문이 돌아온다면 **유비쿼터스 언어로써의 역할**을 못한게 됩니다. 도메인과 관계된 사람들이 공통적으로 의미를 이해할 수 있어야 하기 때문이죠.
        
        따라서 유비쿼터스 언어로 용어를 정의하고 사용할때는 **문서화와 충분한 공유**가 필요할것 같습니다.
        
        그렇다면 일단 D(도메인)가 뭔지는 알겠으니 DD(주도 설계)를 어떻게 해야하는건지 그 방식에 대해 알아보겠습니다.
        
    
    **컴포넌트 기반 패키지**
    
    SOLID, REP, CCP, CRP 등 이 책에서 나온 여러 조언을 저자는 전적으로 동의하지만 '컴포넌트 기반 패키지'라는 또 다른 선택지를 제시하고 있다.
    
    ![스크린샷 2021-12-21 오후 4.54.29.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72ea6755-cca1-4501-843a-a5bef236b73d/스크린샷_2021-12-21_오후_4.54.29.png)
    
    계층형 아키텍처를 다시 말하자면 계층형아키텍처는 의존성 화살표가 항상 아래로 향해야하고 각 계층은 반드시 바로 아래 계층에만 의존해야 함.
    이런 방식으로 깔끔한 비순환 의존성 그래프를 만들 수 있지만 코드베이스의 요소들이 서로 의존할 때는 몇가지 규칙을 반드시 지켜야함.
    그러나 속임수를 써서 몇몇 의존성을 의도치 않은 방식으로 추가하더라도 여전히 좋은 비순환 의존성 그래프가 완성됨.
    → 신입사원의 완화된 계층형 아키텍처
    
    ![스크린샷 2021-12-21 오후 4.54.46.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4c01bf2d-f59a-411b-9f41-f8a1c8fce9b3/스크린샷_2021-12-21_오후_4.54.46.png)
    
    여전히 의존성 화살표는 아래를 향하고 있지만 개별 레코드에 대해 인증된 접근만을 허용하는 일을 업무 로직이 책임지는 경우 바람직하지 못하다
    
    **그래서**
    
    포트와 어댑터에서 웹을 그저 전달 메카니즘으로 취급하는 것과 같이 컴포넌트 기반패키지에서도 사용자 인터페이스를 큰 단위의 컴포넌트로 분리함.
    
    ![스크린샷 2021-12-21 오후 4.56.25.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/644e2125-a19b-42d8-b6ef-466654bd7d7d/스크린샷_2021-12-21_오후_4.56.25.png)
    
    '업무로직'과 영속성 관련 코드를 컴포넌트로써 하나로 묶음.
    컴포넌트 기반 패키지 접근법의 주된 이점은 Orders와 관련된 무언가를 코딩할 때 오직 OrderComponent만 둘러보면 된다.
    즉 MSA나 SOA를 적용했을 때 얻는 이점과 유사함.
    
    엉클밥 형님 컴포넌트를
    
    - 배포단위다
    - 시스템의 구성 요소로 배포할수 있는 가장 작은 단위다
    
    하지만 컴포넌느에 대한 정의는 약간 다르다
    
    - 컴포넌트는 멋지고 깔끔한 인터페이스로 감까진 연관된 기능들의 묶음으로, 애플리케이션과 같은 실행 환경이 내부에 존재한다.
    
    **구현 세부사항엔 항상 문제가 있다.**
    
    앞서 말한 네가지 접근법이 코드를 조직화하는 서로다른 아키텍처 스타일로 여겨질 수 있지만 세부사항을 잘못 구현하면 이런 견해도 빠르게 흐트러짐. 예를들면 public 접근 지시자가 있음.
    
    자바같은 언어에서 public을 지나칠 정도로 방만하게 사용함. 모든 타입에서 public 지시자를 사용한다는것은 프로그래밍 언어가 제공하는 캡슐화 관련 이점을 활용하지 않겠다는것임.
    
    즉, 이로인해 누군가가 구체적인 구현 클래스의 인스턴스를 직접 생성하여 본인이 지향하는 아키텍처 스타일을 위한하게 될 수 있음.
    
    **조직화 VS 캡슐화**
    
    자바 애플리케이션에서 모든 타입을 public으로 지정한다면, 패키지는 단순히 조직화를 위한 매커니즘(폴더구조)으로 전략하여 캡슐화를 위한 메커니즘이 될수 없음. public 지시자를 과용하면 이 장의 앞에서 제시한 네 가지 아키텍처 접근법은 본질적으로 같아짐.
    
    ![https://blog.kakaocdn.net/dn/p1UiY/btqCck2MYLO/XcrI6NyhTeQDayX4ZNkzYK/img.png](https://blog.kakaocdn.net/dn/p1UiY/btqCck2MYLO/XcrI6NyhTeQDayX4ZNkzYK/img.png)
    
    순서대로 계층기반 패키지, 기능기반 패키지, 업무도메인초점인 포트와 어댑터, 컴포넌트기반 패키지 임.
    
    각 타입의 화살표는 채택하려는 아키텍처 접근법과 상관없이 모두 동일한 방향을 가리킴.
    
    자바의 접근지시자를 적절하게 사용하면 타입을 패키지로 배치하는 방식에 따라서 각 타입에 접근할 수 있는 정도가 크게 달라짐.
    
    ![https://blog.kakaocdn.net/dn/bjpej1/btqCbS6A1Lv/KhFLJuyJ8HSA9DCWeCZjLk/img.png](https://blog.kakaocdn.net/dn/bjpej1/btqCbS6A1Lv/KhFLJuyJ8HSA9DCWeCZjLk/img.png)
    
    더 제한적인 접근 지시자를 사용하는 타입은 흐리게 표현됨.
    
    계층기반 패키지에선 OrdersService인터페이스와 OrdersRepository인터페이스는 외부의 패키지로부터 자신이 속한 내부로 들어오는 의존성이 존재하므로 public임. 반면 OrdersServiceImpl와 JdbcOrderRepository 구현체는 protected로 더욱 제한됨.
    
    나머지 접근법들도 마찬가지임. 이제 패키지 외부의 코드에서 OrdersRepository 인터페이스나 구현체를 직접 사용할 방법이 전혀없음.
    
    **다른 결합 분리 모드**
    
    소스코드 의존성 분리는 프로그래밍언어가 제공하는 방법 외에도 자바 OSGi나 자바9에서제공하는 모듈 시스템으로 분리할 수 있음.
    
    다른 선택지로는 소스코드 수준에서 의존성을 분리하는 방법임.
    
    포트와 어댑터로 예로들면
    
    1. 업무와 도메인용 소스 코드: OrderSerivce, OrdersServiceImpl, Orders
    2. 웹용 소스 코드: OrdersController
    3. 데이터 영속성용 소스 코드: JdbcOrderRepository
    
    2, 3번 두 소스 트리는 컴파일 시점에서 업무와 도메인용 소스코드에 의존성을 가지며 업무와 도메인용 소스코드는 웹, 데이터영속성 코드에 대해 알지 못함.
    
    이렇게 분리하려면 → 1, 2, 3 각각은 Maven, Gradle 같은 도구로 서로 분리되도록 구성해야함.
    
    이상적인 해결책이지만 이렇게 나누다 보면 성능, 복잡성, 유지보수 문제에 부딪힘.
    
    더 간단한 방법은
    
    1. 도메인 코드('내부')
    2. 인프라 코드('외부')
    
    로 나누는 것임.
    
    ![https://blog.kakaocdn.net/dn/cuRyl5/btqCbTErB3Z/oIOA1DRtTxsbqLQItLkOYK/img.png](https://blog.kakaocdn.net/dn/cuRyl5/btqCbTErB3Z/oIOA1DRtTxsbqLQItLkOYK/img.png)
    
    인프라는 도메인에 대해 컴파일시점에 의존성을 가짐.
    
    단점으로는 페리페리크(프랑스에있는 원형 순환도로로써 북적대는 파리시내에 진입하지 않고도 파리 전체를 둘러볼 수 있음) 안티패턴임.
    
    즉, 특정영역(인프라코드중 웹 컨트롤러 부분)이 애플리케이션의 다른 영역에 있는 코드를 도메인 코드를 통하지않고 직접 호출할 수 있음.
    
    (적절한 접근 지시자 적용을 잊어버렸다면 더욱 막기 힘듦.)
