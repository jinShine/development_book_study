# 아키텍처란: 경계 해부학

수준을 정의하자면 입력과 출력까지의 거리다. 입.출력과 멀어질수록 정책의 수준은 높아짐.

그림을 보면 번역 컴포넌트는 고수준 컴포넌트겠지?

![스크린샷 2021-11-30 오후 4.32.08.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/028e6cac-d6a8-4d76-bc96-5f8dc1a64567/스크린샷_2021-11-30_오후_4.32.08.png)

데이터흐름은 실선, 의존성은 점선으로 표시됨.

그러므로 데이터흐름과 의존성은 항상 같은 방향을 가리키지 않음.

소스코드 의존성은 그 수준에 따라 결합되어야 하며, 데이터 흐름을 기준으로 결합되어서는 안된다.

- 잘못된 아키텍처 예
    
    ```swift
    // 잘못된 아키텍처.
    function encrypt() {
      while (true)
        writeChar(translate(readChar()));
    }
    ```
    
    위 코드는 고수준인 encrypt 함수가 저수준인 readChar와 writeChar 함수에 의존하기 때문에 잘못된 아키텍처이다.
    
    **개선된 아키텍처**
    
    ![스크린샷 2021-11-30 오후 4.40.34.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fcf0a02f-5bde-4c62-80e0-ea2f14aa798a/스크린샷_2021-11-30_오후_4.40.34.png)
    
    이 구조에서 고수준의 암호화 정책을 저수준의 입력/출력 정책으로부터 분리시킨 방식에 주목
    
    - 입력과 출력에 변화가 생기더라도 암호화 정책은 거의 영향을 받지 않기 때문이다.
