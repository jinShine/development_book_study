# 객체 지향 프로그래밍

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발

흔히들 "실제 세계를 모델링하는 새로운 방법" 이라고 답하지만, 정의가 너무 모호하고 기껏해야 얼버무리는 수준이다

객체지향의 본질

1. 캡슐화
2. 상속
3. 다형성

**캡슐화**

- 데이터와 함수를 구분선 밖에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다
- 하지만 객체 지향 언어로 넘어오면서 캡슐화는 약화되었다.
    - c에서 사용된 헤더와 구현 파일을 분리해서 완벽한 캡슐화 구현이 가능했는데, 이후 C++부터 완전한 캡슐화가 깨지기 시작했다.
    - 기술적인 이유로 클래스의 변수까지 헤더 파일에 변수를 선언하게 해놨기 때문. 물론 접근제한자(public, private 등)를 통해서 컴파일러쪽에서 접근일 막겠지만 사용자 측면쪽에선 멤버 변수가 존재의 사실을 알기 때문에 캡슐화가 깨진것이다.
    - 오늘날의 자바와 Swift, Kotlin등 헤더와 구현체를 분리하는 방식으로 모두 버렸기 때문에 캡슐화의 개념이 심하게 훼손됬다.
    - 때문에 OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들기 때문에, 요즘엔 많은 OO언어가 캡슐화를 거의 강제하지 않는다.

**상속**

- 상속만큼은 OO언어가 확실히 제공했다.
- 상속은 단순히 어떤 변수가 함수를 하나의 유효 범위로 묶어서 재정의하는 일에 불과하다
- 상속은 표현적 편리함을 더했을 뿐 객체 지향만의 새로운 개념이 아니다.

**다형성**

- 다형성 또한 OO에 의해 새롭게 만들어진것이 아니다.
- 함수를 가리키는 포인터를 응용한것이 다형성이다.
- **다형성이 가진 힘**
    - 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다
- **의존성 역전**
    - 기존에는 고수준 함수가 저수준 함수의 모든 이름을 알고 있어야 했기 때문에 제어 흐름은 시스템의 행위에 따라 결정되었고, 소스코드의 의존성은 제어 흐름에 따라 결정되었다.
        
        ![스크린샷 2021-11-08 오전 1.13.39.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8c6f635b-e338-46e3-bfd1-1e687864be88/스크린샷_2021-11-08_오전_1.13.39.png)
        
    - 하지만, 다형성의 등장으로 인해 소스 코드 의존성을 어디서든 역전 시킬수가 있게 되었다.
        
        ![스크린샷 2021-11-08 오전 1.13.57.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/feffb543-750b-4488-acdb-411cf5c37e0b/스크린샷_2021-11-08_오전_1.13.57.png)
        
        의존성 역전(Dependency Inversion) : ML1과 I인터페이스 사이의 소스 코드 의존성(상속관계)이 제어흐름과 반대다.
        
        **의존성은 인터페이스를 추가함으로써 방향을 역전시킬 수 있다.**
        
    - OO는 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다.
- OO를 사용하면 아키텍트는 플러그인 아키텍트를 구성할 수 있고, 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다
- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발 및 배포할 수 있다
