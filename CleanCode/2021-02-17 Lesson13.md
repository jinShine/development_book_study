## 동시성(Concurrency)

### **동시성이 필요한 이유?**

Concurrency는 단일 스레드에서 엮여있던 **'무엇'을 '언제'까지 할껀가**의 의존성을 해소시켜준다.

동시성은 멀티스레드의 동작 방식  
컨텍스트 스위치 방식을 통해 하나의 CPU가 가상으로 여러 스레드를 실행할 수 있게끔 하는 방식을 멀티 스레드  
동시성은 다양한 문제를 일으킬수 있다.  
여러 스레드가 몇개의 리소스를 경쟁적으로 업데이트 하면 예측 불가능한 데이터 문제(레이스컨디션)를 일으키거나, 여러 스레드가 동시에 어떤 이벤트를 기다리는(데드락)문제, 너무 많은 스레드를 사용하는 경우에는 응용프로그램의 메모리가 모자라는 문제가 있을 수 있다.

그럼에도 사용하는 이유는 응답성이 높은 프로그램을 만들기 위해서 사용한다.  
오래걸리는 작업이 실행되는 스레드를 다른 스레드로 실행시켜 사용할 수 있으므로 동시성이 가능.

**오해**

- 동시성은 항상 퍼포먼스를 향상시킨다.  
    ⇒ Concurrency는 여러 스레드 혹은 여러 프로세서가 대기 시간을 공유할 수 있는 경우에만 퍼포먼스를 향상시킨다. 하지만 이러한 경우는 드물다.

- 동시성을 구현해도 설계는 변하지 않는다.  
    ⇒ "무엇"과 "언제"를 분리하는 작업은 보통 시스템의 구조에 큰 영향을 미친다.  
- Web나 EJB와 같은 컨테이너를 사용한다면 Concurrency 문제들은 신경쓸 필요가 없다.  
    ⇒ 컨테이너가 어떤 일을 하는가에 대해 알아야 하며 concurrent update, 데드락을 해결하는 방법을 알아야 한다.

**타당**

- 동시성은 다소 부하를 유발한다.
- 동시성은 복잡하다
- 일반적으로 동시성 버그는 재현이 어렵다
- 동시성을 구현하려면 근본적인 설계 전략을 개편해야한다.

```java
public class X {
    private int lastIdUsed;
    
    public int getNextId() {
        return ++lastIdUsed;
    }
}
```

예를 들어 인스턴스 X를 생성하고 lastIdused 필드를 42로 설정한다음, 두 스레드가 해당 인스턴스를 공유한다고 했을때 한 스레드에서 43을, 다른 스레드에서 43을 똑같이 나오는 잘못된 결과가 나올수도 있다.

### 동시성 방어 원칙

SRP

- 동시성 자체만으로 복잡하기 때문에 다른 코드와 섞이는 난관이 있을 수 있어 다른 코드와 분리해야 한다.

**따름 정리: 자료 범위를 제한하라.**

- 자료를 캡슐화해서 최대한 공유 자료를 줄여라.

**따름 정리: 자료 사본을 사용하라**

- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋지만
- 객체를 복사해 읽기 전용으로 사용하거나, 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능

**따름 정리: 스레드는 가능한 독립적으로 구현하라**

- 각 스레드는 다른 스레드와 자료를 공유하지 않고, 클라이언트 요청 하나를 처리하도록 구현해라
- 독자적인 스레드로, 가능하면 다른 프로세스에서 돌려도 괜찮도록 자료를 독립적인 단위로 분할하라.

### 라이브러리를 이해하라

- 자바 내부 이야기라 Pass

### 실행 모델을 이해하라

**기본용어**

* 한정된 자원 (Bound Resource)  
  * 다중 스레드 환경에서 사용하는 자원. 크기나 숫자가 제한적이다. ex) 데이터베이스 연결, 길이가 일정한 읽기/쓰기 버퍼

* 상호 배제 (Mutual Exclusion)  
  * 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다.
  
* 기아 (Starvation)
  * 스레드가 오래 혹은 영원히 자원을 기다린다. ex) 짧은 스레드에게 우선순위를 준다면, 긴 스레드가 기아 상태에 빠진다.

* 데드락 (Deadlock)
  * 스레드가 서로 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유해 어느쪽도 진행하지 못한다.
  
* 라이브락 (Livelock)	
  * 락을 거는 단계에서 각 스레드가 서로를 방해한다. 오래 혹은 영원히 진행하지 못한다.


**다중 스레드 애플리케이션에서 사용하는 실행 모델**
  - **생산자-소비자 (Producer-Consumer)**

      한 개 이상의 producer가 작업을 생성하여 buffer나 queue에 넣는다. 한 개 이상의 comsumer가 그걸 가져다가 작업한다. 둘 사이의 queue는 bound resource이다. producer는 queue에 공간이 있을 때까지, consumer는 queue에 작업이 하나라도 있을 때까지 기다혀야 한다. producer는 “*queue가 비어있지 않다*“는 signal을 consumer에게 보내고, comsumer는 “*queue가 가득차 있지 않다*“는 signal을 producer에게 보낸다.

  - **읽기-쓰지 (Readers-Writers)**

      Reader가 읽는게 주요 작업이지만 가끔 writer가 쓰는 작업이 필요하다. reader의 throughput을 강조하면 정보가 오랫동안 update가 안될 수 있고, writer의 thoughput을 강조하면 reader의 starvation이 발생하기 쉽다. 양쪽 균형을 어떻게 잡느냐가 중요하다.

  - **식사하는 철학자들 (Dining Philosophers)**

      둥근 식탁에 각자 왼쪽에 포크가 놓여져 있다. 배가 고프면 양쪽 포크 2개를 잡고 스파게티를 먹는다. 양쪽 포크 2개 중 하나라도 없으면 기다려야 한다. 철학자를 thread로, 포크를 자원으로 바꿔 생각해보자. deadlock, livelock, throughput, 효율성 등 문제가 발생하기 쉽다.

  대부분의 경우 위 3가지 중 하나에 속한다.

### 동기화하는 메서드 사이에 존재하는 의존성을 이해하라

- 공유 객체 하나는 메서드 하나만 사용하라

### 동기화하는 부분을 최대한 작게 만들어라

- 락을 설정한 코드는 한 번에 한 스레드만 실행 가능

    → 락은 스레드를 지연시키고 부하를 가중

    → 락의 갯수를 줄이기 위해 거대한 임계영역을 만들면 스레드 간에 경쟁이 늘어나고 프로그램 성능 저하

    → **락의 갯수도 줄이고 그 영역도 최대한 작게 만들어라**

### 스레드 코드 테스트하기

테스트는 정확성을 보장하지 않으며 "코드가 제대로 작성되었는가"를 증명할 수 없다. 다만 잘 작성된 테스트는 위험을 최소화할 수 있다. 이는 멀티 스레드 상황에서는 훨씬 더 복잡해 진다.

*문제를 발생시킬 만한 테스트를 작성하고 여러 프로그램 설정과 시스템 설정, 부하 하에서 자주 수행하라. 테스트가 한번이라도 실패한다면 원인을 분석하라. 한번 더 테스트를 실행해 성공했다고 해서 이전의 실패를 무시하지 마라.*

이는 아래와 같이 분류할 수 있다.

- 말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라
- 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자
- 다중 스레드를 쓰는 코드 부분을 다양한 환경에 쉽게 끼워 넣을 수 있게 스레드 코드를 구현하라
- 다중 스레드를 쓰는 코드 부분을 상황에 맞게 조율할 수 있게 작성하라
- 프로세서 수보다 많은 스레드를 돌려보라
- 다른 플랫폼에서 돌려보라
- 코드에 보조 코드instrument를 넣어 돌려라. 강제로 실패를 일으키게 해보라


심화부분일 수록 번역에 의해서 어렵지 않은 내용들이 많이 어렵게 느껴진다.  
동시성은 제대로 작성하기 어렵고 여러 스레드와 공유 자원이 엮이면 어렵게 되지만,  
SRP를 준수하고, 동시성 오류를 일으키는 잠정적인 원인을 정확하게 이해하고 많은 테스트를 진행해야한다