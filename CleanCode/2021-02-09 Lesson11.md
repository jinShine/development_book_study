## 11. 시스템

### 시스템 제작과 시스템 사용을 분리하라

- 제작(Construction) : 어플리케이션 객체를 제작하고 의존성을 서로 **연결**하는 과정
- 사용(Use) : 제작 과정 이후 이어지는 런타임 과정

대다수 애플리케이션은 시작 **단계라는** 관심사를 분리하지 않는다. 준비 과정 코드를 주먹구구식으로 구현할 뿐만 아니라 런타임 로직과 마구 뒤썩는다.

아래의 예처럼

```swift
public func getService() -> Service {
  if service == nil {
    service = MyServiceImpl(...)
  }

  return service
}
```

초기화 지연(Lazy Initialization) 기법  
장점 : 실제로 필요할 때까지 객체를 생성하지 않으므로 불필요한 부하가 걸리지 않아 시작이 빠르다.  
문제점 :  모든 상황에 적합한 객체인지 몰라 적절하지 않을수있고, nil인 경로와 nil이 아닌경로등의 모든 실행 경로를 테스트해야되기 때문에 SRP에 위반한다.

사실 제일 문제는 객체가 생성되는 시점에 getService라는 메서드를 가지고 있는 객체가 Service 전체를 알 필요가 있을까?

설정과 실행은 분리해야 모듈성이 높아진다.

**Main 분리**  
시스템 생성과 시스템 사용을 분리하는 한가지 방법은 생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고, 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되어 있다고 가장하고 사용만 한다.

main함수에서 시스템에 필요한 객체를 생성한 후 이를 단순 애플리케이션에 넘기기 때문에 애플리케이션은 그저 객체를 사용할 뿐. 즉, 애플리케이션은 main이나 객체가 생성되는 과정을 전혀 모든다.

**팩토리**  
때로는 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.  
이때는 추상 팩토리 패턴(Abstract Factory Pattern)을 사용한다.  
OrderProcessing은 LineItem을 가지고 있지만 생성 방법은 모른다. 그 방법은 LineItemFactory로에서 생성 되어 있기 때문에

**의존성 주입**  
제작과 사용을 분리하는 강력한 방법이 의존성 주입(Dependecy Injection, DI)다.  
제어 역전(Inversion of Control, IoC)기법을 의존성관리에 적용한 메커니즘.  
의존성 생성을 다른 객체에게 맡기므로 SRP를 지키게 된다.

**확장**  
'처음부터 올바르게' 시스템을 만들 수 있다는 믿음은 미신이다. 대신에 오늘은 필요한 것을 만들고, 내일은 거기에 맞춰 확장하면 된다. 이것이 반복적이고 점진적인 애자일 방식의 핵심  
시스템 수준에서는 관심사를 적절히 분리해 나간다면 아키텍처는 점진적으로 발전할 수 있다.  
관심사 분리 실패의 예(EJB1, EJB2)를 200p에서 보여주고 있다.  

**결론**

결론은 시스템 역시 깨끗해야한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리기 때문.  
시스템을 설계하든 개별 모듈을 설계하든 실제로 돌아가는 가장 단순한 수단을 사용하며 모든 추상화 단계에서 의도를 명확히 해야한다.

이 장은 Java 및 Java 진영 프레임워크 이야기로 해당내용은 Pass