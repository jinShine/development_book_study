## 17. 냄새와 휴리스틱

마틴 파울러의 'Refactoring'에서 소개하는 냄새나는 코드의 개선방법과 추가로 로버트 마틴이 생각하는 냄새나는 코드의 개선방법에 대해 설명하는 장

### **주석**

- C1: 부적절한 정보
    - 소스코드 관리 시스템등에 저장할 정보는 주석으로 적절하지 못하며 일반적으로 작성자, 최종 수정일 , SPR(Software Problem Report)번호 등과 같은 메타 정보만 주석으로 사용한다.
- C2: 쓸모 없는 주석
    - 오래된 주석, 엉뚱한 주석, 잘못된 주석은 더 이상 쓸모가 없다.
- C3: 중복된 주석
    - 코드로 알 수 있는 사실은 주석으로 남기지 않는다.

    ```java
    i++ // i 증가
    ```

- C4: 성의 없는 주석
- C5: 주석 처리된 코드
    - 코드를 읽다가 주석으로 처리된 코드가 줄줄이 나오면 얼마나 오래된 코드인지, 중요한 코드인지 아닌지 알 길이 없다. 그럼에도 불구하고 아무도 삭제하지 않는다. 누군가에게 필요하거나 다른사람이 사용할 코드라고 생각하기 때문.
    - 오히려 더 헷갈리게 만든다.

### 환경

- E1: 여러 단계로 빌드해야 한다.
    - 빌드는 간단하게 명령 하나로 빌드 될 수 있도록 해야 한다.
- E2: 여러 단계로 테스트해야 한다.
    - 명령 하나로 모든 테스트를 돌릴 수 있어야 한다.

### 함수

- F1: 너무 많은 인수
    - 함수에서 인수 개수는 작을수록 좋다. 아예 없으면 가장 굳
    - 인수 3개를 넘지 않도록 한다. 넷 이상은 최대한 피하는게 좋다.
- F2: 출력 인수
    - 인수는 입력으로 간주 해야 하고, 일반적으로 출력인수는 피해야 한다.
- F3: 플래그 인수
    - boolean 인수는 함수가 여러 기능을 수행한다는 것을 의미한다.
- F4: 죽은 함수
    - 아무도 호출하지 않는 함수는 삭제해야 한다.
    - 필요하면 버전관리에서 다시 가져오면 된다.

### 일반

- G1: 한 소스 파일에 여러 언어를 사용한다.
    - 소스파일에 쓰이는 언어의 수를 최대한 줄이도록 하자
- G2: 당연한 동작을 구현하지 않는다.
    - 당연하게 여길 만한 동작과 기능은 구현해야 한다.

        ```java
        Day day = DayDate.StringToDay(string dayName);
        ```

    - Monday를 Day.MONDAY로 변환하리라 기대한다.
- G3: 경계를 올바로 처리하지 않는다.
    - 모든 경계 조건을 테스트하는 테스트 케이스를 작성해라
- G4: 안전 절차 무시
    - 테스트 케이스를 작성해라
    - 컴파일러 경고를 끄지마라
- G5: 중복
    - 똑같은 코드가 반복되면 함수로 묶어준다.코드에서 중복을 발견할 때마다 추상화할 기회를 간주하라.
    - switch/case, if/else문으로 똑같은 조건을 거듭 확인할 경우 다형성으로 대체해야 한다.
- G6: 추상화 수준이 올바르지 못하다.
    - 추상화로 개념을 분리할 때는 철저해야 한다. 저차원 개념은 파생클래스에 넣고 고차원 개념은 기초 클래스에 넣어야 한다. 예를들어 세부 구현과 관련한 상수, 변수, 유틸리티 함수는 기초클래스에 넣으면 안된다.
    - 기초 클래스는 구현 정보를 몰라야 한다.

    ```java
    public interface Stack {
     Object pop();
     void push(Object o;
     double percentFull();
    }
    ```

- G7: 기초클래스가 파생클래스에 의존한다
    - 기초클래스는 파생 클래스를 몰라야 한다.
- G8: 과도한 정보
    - 구현 정보를 최소한으로 숨기면 결합도를 낮출 수 있다.
    - 잘 정의된 인터페이스는 많은 함수를 제공하지 않는다. 그래서 결합도가 낮다.
    1. 인터페이스를 작게 만들어가
    2. 상수와 임시 변수는 작을 수록 좋다.
    3. 하위클래스에서 필요하다는 이슈로 protected변수나 함수를 마구 생성하지 마라
- G9: 죽은 코드
    - 실행되지 않는 코드를 가리키며, 설계가 변해도 제대로 수정되지 않기 때문에 제거해야 한다.
- G10: 수직 분리
    - 변수와 함수는 사용되는 위치에 가깝게 정의해야 한다.
- G11: 일관성 부족
    - 어떤 개념을 특장 방식으로 구현했다면 유사한 개념도 같은 방식으로 구현해야한다.(네이밍 포함)
- G12: 잡동사니
    - 아무것도 하지 않는 함수, 호출되지 않는함수 등 필요없는것을 제거해라
- G13: 인위적인 결합
    - 서로 무관한 개념을 인위적으로 결합하지 않는다.
        1. 클래스에 포함된 enum
        2. 특정 클래스에 포함된 범용 static 함수 등
- G14: 기능 욕심
    - 클래스의 메서드는 자기 클래스가 아닌 다른 클래스의 변수와 함수에 관심을 가져서는 안된다.
- G15: 선택자 인수
    - 인수를 넘겨서 동작을 선택하는 대신 새로운 함수를 만드는 편이 좋다.
- G16: 모호한 의도
    - 행을 바꾸지 않고 표현한 수식
    - 헝가리식 표기법, 매직 번호등은 모두 저자의 의도를 흐리게 하기 때문에 지양해야 한다.
- G17: 잘못 지운 책임
    - 독자가 지연스럽게 기대할 위치에 코드는 배치하라
- G18: 부적절한 static 함수
    - 재정의할 가능성이 있는 함수는 static으로 선언해서는 안된다.
- G19: 서술적 변수
    - 프로그램 가독성을 높이는 가장 효과적인 방법 중 하나가 계산을 여러 단계로 나누고 중간 값으로 서울적인 변수 이름을 사용하는 방법
    - 임시 변수를 자주 쓰고, 임시변수에 서술적인 이름을 붙인다.

    ```java
    Matcher match = headerPattern.matcher(line);
    if(match.find()) {
    	String key = match.group(1);
    	String value = match.group(2);
    	headers.put(key.toLowerCase(), value);	
    }
    ```

- G20: 이름과 기능이 일치하는 함수

    ```java
    Date newDate = date.add(5); // X

    // date인스턴스에 5일을 더해 date 인스턴스를 변경하는 함수라면
    addDaysTo 혹은 increaseByDays 같은 이름이 더 좋다.
    ```

- G21: 알고리즘을 이해하라
    - 구현이 끝났으면 함수가 돌아가는 방식을 확실히 이해하는지 확인하는게 중요

- G22: 논리적 의존성은 물리적으로 드러내라

    ```java
     class HourlyReporter{
     int PAGE_SIZE = 55;
     Formatter formatter;	

     private void printAndClearItemList(){
      formatter.format(PAGE_SIZE)
     }
    }
    ```

    위 경우 formatter가 55 PAGE_SIZE를 처리할 수 있음을 가정하는게 논리적 의존성!

    formatter에 getMaxPageSize()라는 메서드를 추가하여 물리적인 의존성으로 변경하자

    ```java
    public void generateReport(List<HourlyEmployee> employess) {
    	...

    	~~if (page.size() == PAGE_SIZE) {~~
    		~~...~~
    	~~}~~

    	if (page.size() == formatter.getMaxPageSize()) {
    		...
    	}
    ~~~~

    }
    ```

- G23: if/else 혹은 switch/case 문보다 다형성을 사용하라
    - 같은 조건문이 반복되면 다형성 객체를 생성해서 switch문을 대신해라
- G24:  표준 표기법을 따르라
    - 업계 표준에 기반한 구현 표준을 따라야 한다. 구현 표준이란 인스턴스 변수이름을 선언하는 위치, 클래스/메서드/변수 이름을 정하는 방법, 괄호를 넣는 위치 등을 명시해야 한다.
    - 표준을 설명하는 문서는 코드 자체로 충분해야 하며 별도 문서를 만들 필요는 없어야 한다.
    - 팀이 정한 표준은 팀원들 모두가 따라야 한다.
- G25: 매직 숫자는 명명된 상수로 교체하라
    - 일반적으로 코드에서 숫자를 사용하지 말라는 규칙이 있다.
    - 숫자는 명명된 상수 뒤로 숨기라는 의미
        - 86,400이라는 숫자는 SECONDS_PER_DAY라는 상수 뒤로 숨긴다.
- G26: 정확하라
    - 결정을 내리는 이유가 분명해야 하며, 예외가 발생할 가능성이 있다면 예외처리를 해주어야 한다.
- G27: 관계보다 구조를 사용하라
    - 설계 결정을 강제할 때는 규칙보다 관례를 사용한다. 고나례는 강제하기 어렵기 때문
- G28: 조건을 캡슐화하라
- G29: 부정 조건은 피하라
    - 부정조건은 긍정조건보다 이해하기 어렵다.
- G30: 함수는 한가지만 해야한다.
- G31: 숨겨진 시간적인 결합
    - 때로는 시간적인 결합이 필요하다. 하지만 시간적인 결합을 숨겨서는 안된다.
    - 함수를 짤때는 함수 인수를 적절히 배치해 함수가 호출되는 순서를 명백히 드러낸다.

        ```java
        public class MoogDriver {
        	Gradient Gradient;
        	List<Spline> splines;

        	~~public void dive(String reason) {
        		saturateGradient();
        		reticulateSplines();
        	}~~
        }

        public class MoogDriver {
        	Gradient Gradient;
        	List<Spline> splines;

        	public void dive(String reason) {
        		Gradient Gradient = saturateGradient();
        		List<Spline> splines = reticulateSplines();
        	}
        }
        ```

        위 코드는 일종의 연결 소자를 생성해 시간적인 결합을 노출한다.

    - G32: 일관성을 유지하라
    - G33: 경계 조건을 캡슐화 하라
        - 경계 조건은 빼먹거나 놓치기 십상이다.
        - 경계 조건은 한 곳에서 별도로 처리한다.

        ```java
        if (level + 1 < tags.length) {
        	parts = newParse(body, tags, level + 1, offset +endTag);
        	body = null
        }
        ```

        level + 1이 두 번 나온다. 이런 경계 조건은 변수로 캡슐화하는 편이 좋다. 변수 이름은 nextLevel이 적합하겠다.

        ```java
        int nextLevel = level + 1

        if (nextLevel < tags.length) {
        	...
        }
        ```

    - G34: 함수는 추상화 수준을 한 단계만 내려가야 한다.
    - G35: 설정 정보는 최상위 단계에 둬라
        - 추상화 최상위 단계에 둬야할 기본값 상수나 설정 관련 상수를 저차원 함수에 숨겨서는 안된다.
    - G36: 추이적 탐색을 피하라
        - 일반적으로 한 모듈은 주변 모듈을 모를수록 좋다.
        - 디미터 법칙

    ### 자바

    - J1: 긴 import목록을 피하고 와일드 카드를 사용하라
    - J2: 상수는 상속하지 않는다.
    - J3: 상수 대 enum
        - 상수를 enum으로 대체할 수 있으면 enum으로 바꿔라

### 이름

- N1: 서술적인 이름을 사용해라
- N2: 적절한 추상화 수준에서 이름을 선택하라
- N3: 가능하다면 표준 명명법을 사용하라
    - 프로젝트에 유효한 의미가 담긴 이름을 많이 사용
- N4: 명확한 이름
    - 함수나 변수의 목적을 명확히 밝히는 이름을 선택
- N5: 긴 범위는 긴 이름을 사용하라
    - 이름 길이는 범위 길이에 비례해야 한다.  범위가 작으면 아주 짧은 이름을 사용해도 괜찮다. 하지만 범위가 길어지면 긴 이름을 사용한다.
- N6: 인코딩을 피하라
    - 접두어 X
- N7: 이름으로 부수 효과를 설명하라

### 테스트

- T1: 불충분한 테스트
    - 테스트는 잠재적으로 깨질만한 부분을 모두 테스트해야한다.
- T2: 커버리지 도구를 사용하라
    - 테스트가 빠진 부분이나 죽은 코드를 쉽게 발견할 수 있다.
- T3: 사소한 테스트를 건너뛰지 마라
- T4: 무시한 테스트는 모호함을 뜻한다.
    - @Ignore
- T5: 경계 조건을 테스트하라
    - 경계 조건에서 실수하는 경우가 흔하다.
- T6: 버그 주변은 철저히 테스트하라
- T7: 실패 패턴을 살펴라
- T8: 테스트 커버리지 패턴을 살펴라
    - 통과하는 테스트가 실행하거나 실행하지 않는 코드를 살펴보면 실패하는 테스트케이스의 실패원인이 드러난다.
- T9: 테스트는 빨라야 한다.

규칙만 따른다고 깨끗한 코드를 얻지 못하며, 휴리스틱 목록을 익힌다고 소프트웨어 장인이 되지 못한다.  
전문가 정신과, 장인 정신에서 나오는 법이다.